#!/opt/sdr/perl/bin/perl
#
#  Copyright (c) 2014 Stefan Parvu (www.systemdatarecorder.org).
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#  (http://www.gnu.org/copyleft/gpl.html)

use strict;
use warnings;
use Getopt::Std;
use Time::HiRes qw(time alarm setitimer ITIMER_REAL);
use Unix::Statgrab;
use POSIX qw(pause);

# Debug Only
# use Data::Dumper;

### Command line arguments
usage() if defined $ARGV[0] and $ARGV[0] eq "--help";
getopts('hV') or usage();
usage()    if defined $main::opt_h;
revision() if defined $main::opt_V;

# process [[interval [count]]
my ( $interval, $loop_max );
if ( defined $ARGV[0] ) {
    $interval = $ARGV[0];
    $loop_max = defined $ARGV[1] ? $ARGV[1] : 2**32;
    usage() if $interval == 0;
}
else {
    $interval = 1;
    $loop_max = 1;
}

### Variables
my %old_nicdata;   # nic stats data
my $loop = 0;      # current loop number
$main::opt_h = 0;  # help option
$main::opt_V = 0;  # revision option
my $tp = 0;        # time precision
local $| = 1;      # autoflush



### MAIN BODY

# how often do we trigger (seconds)?
my $first_interval = $interval;

# signal handler is empty
local $SIG{ALRM} = sub { };

# first value is the initial wait, second is the wait thereafter
setitimer( ITIMER_REAL, $first_interval, $interval );

# check interval input
if ( $interval =~ /\./ ) {
    $tp = 3;
}

while (1) {

    my $current = get_network_io_stats() or 
        croak( get_error()->strperror() );


    my @stats = $current->as_list();

    for my $id ( 0 .. $#stats ) {

        next if $stats[$id]{interface_name} =~ /lo/;

        my $tx = $stats[$id]{tx};
        my $rx = $stats[$id]{rx};
        my $ipck = $stats[$id]{ipackets};
        my $opck = $stats[$id]{opackets};
        my $ierr = $stats[$id]{ierrors};
        my $oerr = $stats[$id]{oerrors};
        my $coll = $stats[$id]{collisions};
        my $stime = $stats[$id]{systime};

        print "$stats[$id]{interface_name}:$tx:$rx:$ipck:$opck:$ierr:$oerr:$coll:$stime\n";

    }

    ### Check for end
    last if ++$loop == $loop_max;

    ### Interval
    pause;

}


### SUBROUTINES

# usage - print usage and exit.
#
sub usage {
    print STDERR <<END;
USAGE: nicrec [-hV] | [interval [count]]
 e.g. nicrec 5       print continuously, every 5 seconds
      nicrec 1 5     print 5 times, every 1 second

 FIELDS:
  #01 timestamp  : seconds since Epoch, time
  #02 nicname    : network interface name, number
  #03 userpct    : cpu utilization, user space, number
  #04 nicepct    : cpu utilization, user space nice priority, number
  #05 syspct     : cpu utilization, system space, number
  #06 irqpct     : cpu percentage servicing interrupts, number
  #07 idlepct    : cpu utilization, idle state, number
  #08 totalpct   : total cpu utilization, number
END
    exit 0;
}


## revision - print revision and exit
sub revision {
    print STDERR <<END;
nicrec: 1.00 build14, 2014-05-04
END
    exit 0;
}
