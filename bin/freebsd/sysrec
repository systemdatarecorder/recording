#!/opt/sdr/perl/bin/perl
#
#  Copyright (c) 2014 Stefan Parvu (www.systemdatarecorder.org).
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#  (http://www.gnu.org/copyleft/gpl.html)

use strict;
use warnings;
use Getopt::Std;
use Time::HiRes qw(time alarm setitimer ITIMER_REAL);
use BSD::Sysctl qw(sysctl);
use POSIX qw(pause);

# Debug Only
# use Data::Dumper;

### Command line arguments
usage() if defined $ARGV[0] and $ARGV[0] eq "--help";
getopts('hV') or usage();
usage()    if defined $main::opt_h;
revision() if defined $main::opt_V;

# process [[interval [count]]
my ( $interval, $loop_max );
if ( defined $ARGV[0] ) {
    $interval = $ARGV[0];
    $loop_max = defined $ARGV[1] ? $ARGV[1] : 2**32;
    usage() if $interval == 0;
}
else {
    $interval = 1;
    $loop_max = 1;
}

### Variables
my $HZ;
my $update;        # used for deltas
my %old_cpudata;   # cpu_stats data
my $loop = 0;      # current loop number
$main::opt_h = 0;  # help option
$main::opt_V = 0;  # revision option
my $tp = 0;        # time precision
local $| = 1;      # autoflush



### MAIN BODY

# Set a timer for S::S::L object
local $SIG{ALRM} = sub { };
setitimer( ITIMER_REAL, .1, .1 );
my $bcpu  = BSD::Sysctl->new( 'kern.cp_times' );
my $bvcpu = BSD::Sysctl->new( 'hw.ncpu' );
my $bla   = BSD::Sysctl->new( 'vm.loadavg' );
### 0.1sec sleep using a timer
pause;

# how often do we trigger (seconds)?
my $first_interval = $interval;

# signal handler is empty
local $SIG{ALRM} = sub { };

# first value is the initial wait, second is the wait thereafter
setitimer( ITIMER_REAL, $first_interval, $interval );

my @order = qw(user nice system idle total irq softirq iowait steal);

# check interval input
if ( $interval =~ /\./ ) {
    $tp = 3;
}

while (1) {

    my $cid = 0;
    
    my $nproc    = $bvcpu->get();
    my $la       = $bla->get();
    my @cpudata = getcpu($nproc);

    ## debug
    # print @cpudata;
    # print $#cpudata;

    foreach my $values (@cpudata) {

        $values =~ s/\:$//;

        my ($u, $n, $s, $r, $i ) = split /:/, $values;

        # across all cpus

        ## debug
        # print "new: $u, $n, $s, $r, $i\n";

        # old values
        my ($old_u, $old_n, $old_s, $old_r, $old_i);

        if (defined $old_cpudata{$cid}) {
            ($old_u, $old_n, $old_s, $old_r, $old_i) = 
                split /:/, $old_cpudata{$cid};
            ##
            # print "old: $old_u, $old_n, $old_s, $old_r, $old_i\n";

        } else {
            $old_u = $old_n = $old_s = $old_r = $old_i = 0;
        }


        my $ticks = cpu_ticks($old_u, $u);
        $ticks = $ticks + cpu_ticks($old_n, $n);
        $ticks = $ticks + cpu_ticks($old_s, $s);
        $ticks = $ticks + cpu_ticks($old_r, $r);
        $ticks = $ticks + cpu_ticks($old_i, $i);

        my $etime = $ticks; 
        if ($etime == 0) { $etime = 1; }

        my $percent = 100 / $etime;
      
        my $user     = delta($old_u, $u) * $percent;
        my $nice     = delta($old_n, $n) * $percent;
        my $sys      = delta($old_s, $s) * $percent;
        my $intr     = delta($old_r, $r) * $percent;
        my $idle     = delta($old_i, $i) * $percent;
        my $cpupct   = $user + $nice + $sys + $intr;
        my $sumpct   = $cpupct * $nproc;
        my $headpct  = ($nproc * 100) - $sumpct;

        printf "%.${tp}f:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f\n",
                time, $cpupct, $sumpct, $headpct, 
                $user, $nice, $sys, $intr, $idle,
                $la->[0], $la->[1], $la->[2];

        $old_cpudata{$cid} = "$u:$n:$s:$r:$i";

    }

    ### Check for end
    last if ++$loop == $loop_max;

    ### Interval
    pause;

}


### SUBROUTINES

# usage - print usage and exit.
#
sub usage {
    print STDERR <<END;
USAGE: sysrec [-hV] | [interval [count]]
 e.g. sysrec 5       print continuously, every 5 seconds
      sysrec 1 5     print 5 times, every 1 second

 FIELDS:
  CPU
   #01 timestamp  : seconds since Epoch, time
   #02 cpupct     : cpu utilization, across all cpus, number
   #03 sumpct     : sum of all cpus utilization, number
   #04 headpct    : headroom cpu available, all cpus, number
   #05 userpct    : cpu utilization, user space in percent, number
   #06 nicepct    : cpu utilization, user space with nice priority, number
   #07 sysct      : cpu utilization, system space, number
   #08 irqpct     : cpu percentage servicing interrupts, number
   #09 idlepct    : cpu utilization, idle state, number
   #10 runqsz     : run queue length, tasks waiting for run time, number

   #41 avg_1      : LA of the last minute, number
   #42 avg_5      : LA of the last 5 minutes, number
   #43 avg_15     : LA of the last 15 minutes, number
END
    exit 0;
}


## revision - print revision and exit
sub revision {
    print STDERR <<END;
sysrec: 1.00 build14, 2014-05-04
END
    exit 0;
}


## getcpu
sub getcpu {

    my $ncpu = shift;
    my @cdata = ();

    ### Get Stats
    my $cpu_times = $bcpu->get();

    my $len = $#{ $cpu_times };

    my $count = 0;
    my $cpuid = 0;
    my $cpusem = 0;
    my ($us, $ni, $sy, $iq, $id) = 0;

    for (my $i=0; $i<$len+1; $i++) {
         ## debug
         # print "|${ $ cpu_times}[$i]|";

         if ($count == 0) {
              $us += "${$cpu_times}[$i]";
         }

         if ($count == 1) {
             $ni += "${$cpu_times}[$i]";
         }
 
         if ($count == 2 ) {
             $sy += "${$cpu_times}[$i]";
         }

         if ($count == 3) {
             $iq += "${$cpu_times}[$i]";
         }

         if ($count == 4) {
             $id += "${$cpu_times}[$i]";
         }

         $count++;

         if ($count == 5) {
             $count=0;
         }
    }

    $us = sprintf("%.2f", $us / $ncpu);
    $ni = sprintf("%.2f", $ni / $ncpu);
    $sy = sprintf("%.2f", $sy / $ncpu);
    $iq = sprintf("%.2f", $iq / $ncpu);
    $id = sprintf("%.2f", $id / $ncpu);

    ## debug
    # print "$us $ni $sy $iq $id"; 

    my $payload = $us . ":" .  $ni . ":" . $sy . ":" . $iq . ":" . $id;

    push @cdata, $payload;

    return @cdata;
}


sub cpu_ticks {
    my ($old, $new) = @_;
    my $lticks = 0;

    my $d = delta($old, $new);
    $lticks += $d;

    return $lticks;
}


sub delta {
    my ($old, $new) = @_;
    return $new - $old;
}
