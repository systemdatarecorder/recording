#!/opt/sdr/perl/bin/perl
#
#  Copyright (c) 2014 Stefan Parvu (www.systemdatarecorder.org).
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#  (http://www.gnu.org/copyleft/gpl.html)

use strict;
use warnings;
use Getopt::Std;
use Time::HiRes qw(time alarm setitimer ITIMER_REAL);
use BSD::Sysctl qw(sysctl);
use BSD::devstat;
use POSIX qw(pause);

# Debug Only
# use Data::Dumper;

### Command line arguments
usage() if defined $ARGV[0] and $ARGV[0] eq "--help";
getopts('hV') or usage();
usage()    if defined $main::opt_h;
revision() if defined $main::opt_V;

# process [[interval [count]]
my ( $interval, $loop_max );
if ( defined $ARGV[0] ) {
    $interval = $ARGV[0];
    $loop_max = defined $ARGV[1] ? $ARGV[1] : 2**32;
    usage() if $interval == 0;
}
else {
    $interval = 1;
    $loop_max = 1;
}

### Variables
my %old_diskdata;  # disk_stats data
my $loop = 0;      # current loop number
$main::opt_h = 0;  # help option
$main::opt_V = 0;  # revision option
my $tp = 0;        # time precision
my $calibration;   # calibration time
local $| = 1;      # autoflush



### MAIN BODY

# Set a timer for BSD::Sysctl object
local $SIG{ALRM} = sub { };
setitimer( ITIMER_REAL, .1, .1 );
my $bds = BSD::devstat->new();
### 0.1sec sleep using a timer
pause;

# how often do we trigger (seconds)?
my $first_interval = $interval;

# signal handler is empty
local $SIG{ALRM} = sub { };

# first value is the initial wait, second is the wait thereafter
setitimer( ITIMER_REAL, $first_interval, $interval );

# check interval input
if ( $interval =~ /\./ ) {
    $tp = 3;
}


# intial calibration
my $ndisks = $bds->numdevs;
$calibration = $interval / $ndisks;

while (1) {

    # get new devstats
    $bds = BSD::devstat->new();

    my $start = time;

    ## per disk stats 
    my @dstats = get_devstat($bds, $calibration);

    my $end = time;

    my $delta = $end - $start;

    $calibration =  ( $interval - $delta ) / $#dstats;

    #if ($delta > $calibration) {
    #    $calibration = $calibration / $delta;
    #} else {
    #    $calibration = $calibration - $delta;
    #} 

    print "main: calibration=$calibration\n";
    print "main: delta=$delta\n";

    # $elapsed = ($end - $start) - ($#dstats / $interval);
    # $elapsed = (( $end - $start ) / $#dstats ); 
 
    foreach my $values (@dstats) {

        $values =~ s/\:$//;

        my ($name, 
            $reads,  $rkbytes, $rreads, 
            $writes, $wkbytes, $rwrites, 
            $rtotal, $queue,   $busy ) = split /:/, $values;

        # old values
        #my ($o_reads,  $o_rkbytes, $o_rreads, 
        #     $o_writes, $o_wkbytes, $o_rwrites, 
        #     $o_rtotal, $o_queue,   $o_busy, $o_stime );

        #if (defined $old_diskdata{$name}) {
        #   ($o_reads,  $o_rkbytes, $o_rreads, 
        #    $o_writes, $o_wkbytes, $o_rwrites, 
        #    $o_rtotal, $o_queue,   $o_busy, $o_stime ) =
        #        split /:/, $old_diskdata{$name};
#
        #} else {
#
        #    $o_reads = $o_rkbytes = $o_rreads = $o_writes = 
        #    $o_wkbytes = $o_rwrites = $o_rtotal = $o_queue = $o_busy = $o_stime  = 0;
        #}

        # print "time=$stime old=$o_stime\n";

        #if ($o_stime == 0) {
        #     $elapsed = 0.05;
        #} else {
        #     $elapsed = $stime - $o_stime;
        #}

        

        printf "%.${tp}f:%s:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f\n",
               time, $name, $reads, $rkbytes, $rreads,
               $writes, $wkbytes, $rwrites, $rtotal, $queue, $busy;
        # save old data
        #$old_diskdata{$name} = "$reads:$rkbytes:$rreads:$writes:$wkbytes:$rwrites:$rtotal:$queue:$busy:$stime";

    }

    print "\n";
    ### Check for end
    last if ++$loop == $loop_max;

    ### Interval
    pause;

}


### SUBROUTINES

# usage - print usage and exit.
#
sub usage {
    print STDERR <<END;
USAGE: diskrec [-hV] | [interval [count]]
 e.g. diskrec 5       print continuously, every 5 seconds
      diskrec 1 5     print 5 times, every 1 second

 FIELDS:
  #01 timestamp  : seconds since Epoch, time
  #02 cpuid      : cpuid, number
  #03 userpct    : cpu utilization, user space, number
  #04 nicepct    : cpu utilization, user space nice priority, number
  #05 syspct     : cpu utilization, system space, number
  #06 irqpct     : cpu percentage servicing interrupts, number
  #07 idlepct    : cpu utilization, idle state, number
  #08 totalpct   : total cpu utilization, number
END
    exit 0;
}


## revision - print revision and exit
sub revision {
    print STDERR <<END;
cpurec: 1.00 build14, 2014-05-04
END
    exit 0;
}


sub get_devstat {

    my ($bdev, $cal) = @_;

    my (@stats);

    print "get_devstat: calibration=$cal\n";

    ## get disk stats
    for(my $i=0; $i < $bdev->numdevs; $i++) {

         my $dev = $bdev->devices($i);

         # filter the names
         next if $dev->{device_name} =~ /pass|cd/;

         my $d   = "$dev->{device_name}$dev->{unit_number}";

         my $stat = $bdev->compute_statistics($i, $cal);
         
         # MB_PER_SECOND BLOCKS_PER_SECOND_WRITE MS_PER_TRANSACTION_WRITE 
         # KB_PER_TRANSFER TRANSFERS_PER_SECOND_OTHER TOTAL_TRANSFERS 
         # MB_PER_SECOND_READ QUEUE_LENGTH BLOCKS_PER_SECOND_READ TOTAL_BYTES_FREE 
         # BLOCKS_PER_SECOND_FREE TOTAL_TRANSFERS_WRITE MB_PER_SECOND_WRITE 
         # TOTAL_BYTES_READ TOTAL_BYTES TOTAL_BLOCKS_FREE TRANSFERS_PER_SECOND 
         # KB_PER_TRANSFER_READ MS_PER_TRANSACTION_OTHER TOTAL_TRANSFERS_READ 
         # BUSY_PCT BLOCKS_PER_SECOND TOTAL_TRANSFERS_FREE TOTAL_BLOCKS_WRITE 
         # TOTAL_TRANSFERS_OTHER TOTAL_BLOCKS MB_PER_SECOND_FREE 
         # TRANSFERS_PER_SECOND_WRITE TOTAL_BLOCKS_READ TRANSFERS_PER_SECOND_READ 
         # TOTAL_BYTES_WRITE MS_PER_TRANSACTION_FREE TRANSFERS_PER_SECOND_FREE 
         # KB_PER_TRANSFER_WRITE MS_PER_TRANSACTION KB_PER_TRANSFER_FREE 
         # MS_PER_TRANSACTION_READ

         my $xr  = $stat->{TRANSFERS_PER_SECOND_READ};
         my $xbr = $stat->{MB_PER_SECOND_READ} * 1024;
         my $rr  = $stat->{MS_PER_TRANSACTION_READ};
         
         my $xw  = $stat->{TRANSFERS_PER_SECOND_WRITE};
         my $xbw = $stat->{MB_PER_SECOND_WRITE} * 1024;
         my $rw  = $stat->{MS_PER_TRANSACTION_WRITE};

         my $r   = $stat->{MS_PER_TRANSACTION};
         my $q   = $stat->{QUEUE_LENGTH};
         my $b   = $stat->{BUSY_PCT};
 
         my $payload = "$d:$xr:$xbr:$rr:$xw:$xbw:$rw:$r:$q:$b";

         push @stats, $payload;

    }

    return @stats;
}


sub delta {
    my ($old, $new) = @_;
    return $new - $old;
}
