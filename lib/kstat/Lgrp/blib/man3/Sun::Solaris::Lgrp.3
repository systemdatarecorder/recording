.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "pod::Lgrp 3"
.TH pod::Lgrp 3 "2014-09-04" "perl v5.20.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Lgrp \- Perl interface to Solaris liblgrp library.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Sun::Solaris::Lgrp qw(:ALL);
\&
\&  # initialize lgroup interface
\&  my $cookie = lgrp_init(LGRP_VIEW_OS | LGRP_VIEW_CALLER);
\&  my $l = Sun::Solaris::Lgrp\->new(LGRP_VIEW_OS | LGRP_VIEW_CALLER);
\&
\&  my $version = lgrp_version(LGRP_VER_CURRENT | LGRP_VER_NONE);
\&  $version = $l\->version(LGRP_VER_CURRENT | LGRP_VER_NONE);
\&
\&  $home = lgrp_home(P_PID, P_MYID);
\&  $home = l\->home(P_PID, P_MYID);
\&
\&  lgrp_affinity_set(P_PID, $pid, $lgrp,
\&        LGRP_AFF_STRONG | LGRP_AFF_WEAK | LGRP_AFF_NONE);
\&  $l\->affinity_set(P_PID, $pid, $lgrp,
\&        LGRP_AFF_STRONG | LGRP_AFF_WEAK | LGRP_AFF_NONE);
\&
\&  my $affinity = lgrp_affinity_get(P_PID, $pid, $lgrp);
\&  $affinity = $l\->affinity_get(P_PID, $pid, $lgrp);
\&
\&  my $nlgrps = lgrp_nlgrps($cookie);
\&  $nlgrps = $l\->nlgrps();
\&
\&  my $root = lgrp_root($cookie);
\&  $root = l\->root();
\&
\&  $latency = lgrp_latency($lgrp1, $lgrp2);
\&  $latency = $l\->latency($lgrp1, $lgrp2);
\&
\&  my @children = lgrp_children($cookie, $lgrp);
\&  @children = l\->children($lgrp);
\&
\&  my @parents = lgrp_parents($cookie, $lgrp);
\&  @parents = l\->parents($lgrp);
\&
\&  my @lgrps = lgrp_lgrps($cookie);
\&  @lgrps = l\->lgrps();
\&
\&  @lgrps = lgrp_lgrps($cookie, $lgrp);
\&  @lgrps = l\->lgrps($lgrp);
\&
\&  my @leaves = lgrp_leaves($cookie);
\&  @leaves = l\->leaves();
\&
\&  my $is_leaf = lgrp_isleaf($cookie, $lgrp);
\&  $is_leaf = $l\->is_leaf($lgrp);
\&
\&  my @cpus = lgrp_cpus($cookie, $lgrp,
\&        LGRP_CONTENT_HIERARCHY | LGRP_CONTENT_DIRECT);
\&  @cpus = l\->cpus($lgrp, LGRP_CONTENT_HIERARCHY | LGRP_CONTENT_DIRECT);
\&
\&  my $memsize = lgrp_mem_size($cookie, $lgrp,
\&        LGRP_MEM_SZ_INSTALLED | LGRP_MEM_SZ_FREE,
\&        LGRP_CONTENT_HIERARCHY | LGRP_CONTENT_DIRECT);
\&  $memsize = l\->mem_size($lgrp,
\&        LGRP_MEM_SZ_INSTALLED | LGRP_MEM_SZ_FREE,
\&        LGRP_CONTENT_HIERARCHY | LGRP_CONTENT_DIRECT);
\&
\&  my $is_stale = lgrp_cookie_stale($cookie);
\&  $stale = l\->stale();
\&
\&  lgrp_fini($cookie);
\&
\&  # The following is available for API version greater than 1:
\&
\&  my @lgrps = lgrp_resources($cookie, $lgrp, LGRP_RSRC_CPU);
\&
\&  # Get latencies from cookie
\&  $latency = lgrp_latency_cookie($cookie, $from, $to);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides access to the \f(CW\*(C`liblgrp(3LIB)\*(C'\fR library and to various
constants and functions defined in \f(CW\*(C`sys/lgrp_sys.h\*(C'\fR header file. It provides
both the procedural and object interface to the library. The procedural
interface requires (in most cases) passing a transparent cookie around. The
object interface hides all the cookie manipulations from the user.
.PP
Functions returning scalar value indicate error by returning \fBundef\fR. The
caller may examine the \fB$!\fR variable to get the \f(CW\*(C`errno\*(C'\fR value.
.PP
Functions returning list value return the number of elements in the list when
called in scalar context. In case of error the empty list is return in the array
context and \fBundef\fR is returned in the scalar context.
.SS "\s-1CONSTANTS\s0"
.IX Subsection "CONSTANTS"
The constants are exported with \fB:CONSTANTS\fR or \fB:ALL\fR tags:
.PP
.Vb 1
\&  use Sun::Solaris::Lgrp \*(Aq:ALL\*(Aq;
.Ve
.PP
or
.PP
.Vb 1
\&  use Sun::Solaris::Lgrp \*(Aq:CONSTANTS\*(Aq;
.Ve
.PP
The following constants are available for use in Perl programs:
.PP
.Vb 1
\&  LGRP_NONE
\&
\&  LGRP_VER_CURRENT
\&  LGRP_VER_NONE
\&
\&  LGRP_VIEW_CALLER
\&  LGRP_VIEW_OS
\&
\&  LGRP_AFF_NONE
\&  LGRP_AFF_STRONG
\&  LGRP_AFF_WEAK
\&
\&  LGRP_CONTENT_DIRECT
\&  LGRP_CONTENT_HIERARCHY
\&
\&  LGRP_MEM_SZ_FREE
\&  LGRP_MEM_SZ_INSTALLED
\&
\&  LGRP_RSRC_CPU (1)
\&  LGRP_RSRC_MEM (1)
\&  LGRP_CONTENT_ALL (1)
\&  LGRP_LAT_CPU_TO_MEM(1)
\&
\&  P_PID
\&  P_LWPID
\&  P_MYID
.Ve
.PP
(1) Available for versions of the liblgrp(3LIB) \s-1API\s0 greater than 1.
.SS "functions"
.IX Subsection "functions"
A detailed description of each function follows. Since this module is intended
to provide a Perl interface to the routines in liblgrp(3LIB), a very short
description is given for the corresponding functions in this module and a
reference is given to the complete description in the liblgrp(3LIB) man
pages. Any differences or additional functionality in the Perl module are
highlighted and fully documented here.
.IP "lgrp_init([\s-1LGRP_VIEW_CALLER\s0 | \s-1LGRP_VIEW_OS\s0])" 4
.IX Item "lgrp_init([LGRP_VIEW_CALLER | LGRP_VIEW_OS])"
The function initializes the lgroup interface and takes a snapshot of the lgroup
hierarchy with the given view. Given the view, \fIlgrp_init()\fR returns a cookie
representing this snapshot of the lgroup hierarchy. This cookie should be used
with other routines in the lgroup interface needing the lgroup hierarchy. The
\&\fIlgrp_fini()\fR function should be called with the cookie when it is no longer
needed. Unlike lgrp_init (3LGRP), \f(CW\*(C`LGRP_VIEW_OS\*(C'\fR is assumed as the default if
no view is provided.
.Sp
Upon successful completion, \fIlgrp_init()\fR returns a cookie. Otherwise it returns
\&\fBundef\fR and sets \fB$!\fR to indicate the error.
.Sp
See lgrp_init(3LGRP) for more information.
.IP "lgrp_fini($cookie)" 4
.IX Item "lgrp_fini($cookie)"
The function takes a cookie, frees the snapshot of the lgroup hierarchy created
by \fIlgrp_init()\fR, and cleans up anything else set up by \fIlgrp_init()\fR. After
this function is called, the cookie returned by the lgroup interface might no
longer be valid and should not be used.
.Sp
Upon successful completion, 1 is returned. Otherwise, \fBundef\fR is returned and
\&\fB$!\fR is set to indicate the error.
.Sp
See lgrp_fini(3LGRP) for more information.
.IP "lgrp_view($cookie)" 4
.IX Item "lgrp_view($cookie)"
The function takes a cookie representing the snapshot of the lgroup hierarchy
and returns the snapshot's view of the lgroup hierarchy.
.Sp
If the given view is \f(CW\*(C`LGRP_VIEW_CALLER\*(C'\fR, the snapshot contains only the
resources that are available to the caller (such as those with respect to
processor sets).  When the view is \f(CW\*(C`LGRP_VIEW_OS\*(C'\fR, the snapshot contains what
is available to the operating system.
.Sp
Upon succesful completion, the function returns the view for the snapshot of the
lgroup hierarchy represented by the given cookie. Otherwise, \fBundef\fR is
returned and \f(CW$!\fR is set.
.Sp
See lgrp_view(3LGRP) for more information.
.ie n .IP "lgrp_home($idtype, $id)" 4
.el .IP "lgrp_home($idtype, \f(CW$id\fR)" 4
.IX Item "lgrp_home($idtype, $id)"
Returns the home lgroup for the given process or thread. The \fB\f(CB$idtype\fB\fR argument
should be \f(CW\*(C`P_PID\*(C'\fR to specify a process and the \fB\f(CB$id\fB\fR argument should be its
process id. Otherwise, the \fB\f(CB$idtype\fB\fR argument should be \f(CW\*(C`P_LWPID\*(C'\fR to specify a
thread and the \fB\f(CB$id\fB\fR argument should be its \s-1LWP\s0 id. The value \f(CW\*(C`P_MYID\*(C'\fR can be
used for the id argument to specify the current process or thread.
.Sp
Upon successful completion, \f(CW\*(C`lgrp_home()\*(C'\fR returns the id of the home lgroup of
the specified process or thread. Otherwise, \fBundef\fR is returned and \fB$!\fR is
set to indicate the error.
.Sp
See lgrp_home(3LGRP) for more information.
.IP "lgrp_cookie_stale($cookie)" 4
.IX Item "lgrp_cookie_stale($cookie)"
Upon successful completion, the function returns whether the cookie is
stale. Otherwise, it returns \fBundef\fR and sets \fB$!\fR to indicate the error.
.Sp
The \fIlgrp_cookie_stale()\fR function will fail with \f(CW\*(C`EINVAL\*(C'\fR if the cookie is
not valid.
.Sp
See lgrp_cookie_stale(3LGRP) for more information.
.ie n .IP "lgrp_cpus($cookie, $lgrp, $context)" 4
.el .IP "lgrp_cpus($cookie, \f(CW$lgrp\fR, \f(CW$context\fR)" 4
.IX Item "lgrp_cpus($cookie, $lgrp, $context)"
The function takes a cookie representing a snapshot of the lgroup hierarchy and
returns the list of CPUs in the lgroup specified by \fB\f(CB$lgrp\fB\fR. The \fB\f(CB$context\fB\fR
argument should be set to one of the following values to specify whether the
direct contents or everything in this lgroup including its children should be
returned:
.RS 4
.IP "\s-1LGRP_CONTENT_HIERARCHY\s0" 4
.IX Item "LGRP_CONTENT_HIERARCHY"
Everything within this hierarchy.
.IP "\s-1LGRP_CONTENT_DIRECT\s0" 4
.IX Item "LGRP_CONTENT_DIRECT"
Directly contained in lgroup.
.RE
.RS 4
.Sp
When called in scalar context, \fIlgrp_cpus()\fR function returns the number of
CPUs, contained in the specified lgroup.
.Sp
In case of error \fBundef\fR is returned in scalar context and \fB$!\fR is set to
indicate the error. In list context the empty list is returned and \fB$!\fR is set.
.Sp
See lgrp_cpus(3LGRP) for more information.
.RE
.ie n .IP "lgrp_children($cookie, $lgrp)" 4
.el .IP "lgrp_children($cookie, \f(CW$lgrp\fR)" 4
.IX Item "lgrp_children($cookie, $lgrp)"
The function takes a cookie representing a snapshot of the lgroup hierarchy and
returns the list of lgroups that are children of the specified lgroup.
.Sp
When called in scalar context, \fIlgrp_children()\fR function returns the number of
children lgroups for the specified lgroup.
.Sp
In case of error \fBundef\fR or empty list is returned and \fB$!\fR is set to indicate
the error.
.Sp
See lgrp_children(3LGRP) for more information.
.ie n .IP "lgrp_parents($cookie, $lgrp)" 4
.el .IP "lgrp_parents($cookie, \f(CW$lgrp\fR)" 4
.IX Item "lgrp_parents($cookie, $lgrp)"
The function takes a cookie representing a snapshot of the lgroup hierarchy and
returns the list of parent of the specified lgroup.
.Sp
When called in scalar context, \fIlgrp_parents()\fR function returns the number of
parent lgroups for the specified lgroup.
.Sp
In case of error \fBundef\fR or empty list is returned and \fB$!\fR is set to indicate
the error.
.Sp
See lgrp_parents(3LGRP) for more information.
.IP "lgrp_nlgrps($cookie)" 4
.IX Item "lgrp_nlgrps($cookie)"
The function takes a cookie representing a snapshot of the lgroup hierarchy.  It
returns the number of lgroups in the hierarchy where the number is always at
least one.
.Sp
In case of error \fBundef\fR is returned and \fB$!\fR is set to \s-1EINVAL\s0 indicatng that
the cookie is not valid.
.Sp
See lgrp_nlgrps(3LGRP) for more information.
.IP "lgrp_root($cookie)" 4
.IX Item "lgrp_root($cookie)"
The function returns the root lgroup \s-1ID. \s0 In case of error \fBundef\fR is returned
and \fB$!\fR is set to \s-1EINVAL\s0 indicatng that the cookie is not valid.
.Sp
See lgrp_root(3LGRP) for more information.
.ie n .IP "lgrp_mem_size($cookie, $lgrp, $type, $content)" 4
.el .IP "lgrp_mem_size($cookie, \f(CW$lgrp\fR, \f(CW$type\fR, \f(CW$content\fR)" 4
.IX Item "lgrp_mem_size($cookie, $lgrp, $type, $content)"
The function takes a cookie representing a snapshot of the lgroup hierarchy. The
function returns the memory size of the given lgroup in bytes. The \fB\f(CB$type\fB\fR
argument should be set to one of the following values:
.RS 4
.IP "\s-1LGRP_MEM_SZ_FREE\s0" 4
.IX Item "LGRP_MEM_SZ_FREE"
Free memory.
.IP "\s-1LGRP_MEM_SZ_INSTALLED\s0" 4
.IX Item "LGRP_MEM_SZ_INSTALLED"
Installed memory.
.RE
.RS 4
.Sp
The \fB\f(CB$content\fB\fR argument should be set to one of the following values to specify
whether the direct contents or everything in this lgroup including its children
should be returned:
.IP "\s-1LGRP_CONTENT_HIERARCHY\s0" 4
.IX Item "LGRP_CONTENT_HIERARCHY"
Everything within this hierarchy.
.IP "\s-1LGRP_CONTENT_DIRECT\s0" 4
.IX Item "LGRP_CONTENT_DIRECT"
Directly contained in lgroup.
.RE
.RS 4
.Sp
The total sizes include all the memory in the lgroup including its children,
while the others reflect only the memory contained directly in the given lgroup.
.Sp
Upon successful completion, the size in bytes is returned. Otherwise, \fBundef\fR
is returned and \fB$!\fR is set to indicate the error.
.Sp
See lgrp_mem_size(3LGRP) for more information.
.RE
.IP "lgrp_version([$version])" 4
.IX Item "lgrp_version([$version])"
The function takes an interface version number, B$version>, as an argument and
returns an lgroup interface version. The \fB\f(CB$version\fB\fR argument should be the
value of \f(CW\*(C`LGRP_VER_CURRENT\*(C'\fR or \f(CW\*(C`LGRP_VER_NONE\*(C'\fR to find out the current lgroup
interface version on the running system.
.Sp
If \fB\f(CB$version\fB\fR is still supported by the implementation, then \fIlgrp_version()\fR
returns the requested version. If \f(CW\*(C`LGRP_VER_NONE\*(C'\fR is returned, the
implementation cannot support the requested version.
.Sp
If \fB\f(CB$version\fB\fR is \f(CW\*(C`LGRP_VER_NONE\*(C'\fR, \fIlgrp_version()\fR returns the current version of
the library.
.Sp
The following example  tests  whether  the  version  of  the
interface used by the caller is supported:
.Sp
.Vb 2
\&    lgrp_version(LGRP_VER_CURRENT) == LGRP_VER_CURRENT or
\&        die("Built with unsupported lgroup interface");
.Ve
.Sp
See lgrp_version(3LGRP) for more information.
.ie n .IP "lgrp_affinity_set($idtype, $id, $lgrp, $affinity)" 4
.el .IP "lgrp_affinity_set($idtype, \f(CW$id\fR, \f(CW$lgrp\fR, \f(CW$affinity\fR)" 4
.IX Item "lgrp_affinity_set($idtype, $id, $lgrp, $affinity)"
The function sets of LWPs specified by the \fB\f(CB$idtype\fB\fR and \fB\f(CB$id\fB\fR arguments have
for the given lgroup.
.Sp
The function sets the affinity that the \s-1LWP\s0 or set of LWPs specified by \f(CW$idtype\fR
and \f(CW$id\fR have for the given lgroup. The lgroup affinity can be set to
\&\f(CW\*(C`LGRP_AFF_STRONG\*(C'\fR, \f(CW\*(C`LGRP_AFF_WEAK\*(C'\fR, or \f(CW\*(C`LGRP_AFF_NONE\*(C'\fR.
.Sp
If the \fB\f(CB$idtype\fB\fR is \f(CW\*(C`P_PID\*(C'\fR, the affinity is retrieved for one of the LWPs in
the process or set for all the LWPs of the process with process id (\s-1PID\s0) \fB\f(CB$id\fB\fR.
The affinity is retrieved or set for the \s-1LWP\s0 of the current process with \s-1LWP\s0 id
\&\f(CW$id\fR if idtype is \f(CW\*(C`P_LWPID\*(C'\fR. If \f(CW$id\fR is \f(CW\*(C`P_MYID\*(C'\fR, then the current \s-1LWP\s0 or
process is specified.
.Sp
There are different levels of affinity that can be specified by a thread for a
particuliar lgroup.  The levels of affinity are the following from strongest to
weakest:
.RS 4
.IP "\s-1LGRP_AFF_STRONG\s0" 4
.IX Item "LGRP_AFF_STRONG"
Strong affinity.
.IP "\s-1LGRP_AFF_WEAK\s0" 4
.IX Item "LGRP_AFF_WEAK"
Weak affinity.
.IP "\s-1LGRP_AFF_NONE\s0" 4
.IX Item "LGRP_AFF_NONE"
No affinity.
.RE
.RS 4
.Sp
Upon successful completion, \fIlgrp_affinity_set()\fR return 1.  Otherwise, it
returns \fBundef\fR and set \fB$!\fR to indicate the error.
.Sp
See lgrp_affinity_set(3LGRP) for more information.
.RE
.ie n .IP "lgrp_affinity_get($idtype, $id, $lgrp)" 4
.el .IP "lgrp_affinity_get($idtype, \f(CW$id\fR, \f(CW$lgrp\fR)" 4
.IX Item "lgrp_affinity_get($idtype, $id, $lgrp)"
The function returns the affinity that the \s-1LWP\s0 has to a given lgrp. See
\&\fIlgrp_affinity_get()\fR for detailed description.
.Sp
See lgrp_affinity_get(3LGRP) for more information.
.ie n .IP "lgrp_latency_cookie($cookie, $from, $to, [$between=LGRP_LAT_CPU_TO_MEM])" 4
.el .IP "lgrp_latency_cookie($cookie, \f(CW$from\fR, \f(CW$to\fR, [$between=LGRP_LAT_CPU_TO_MEM])" 4
.IX Item "lgrp_latency_cookie($cookie, $from, $to, [$between=LGRP_LAT_CPU_TO_MEM])"
The function takes a cookie representing a snapshot of the lgroup hierarchy and
returns the latency value between a hardware resource in the \f(CW$from\fR lgroup to a
hardware resource in the \fB\f(CB$to\fB\fR lgroup. If \fB\f(CB$from\fB\fR is the same lgroup as \f(CW$to\fR, the
latency value within that lgroup is returned.
.Sp
The optional \fBbetween\fR argument should be set to \f(CW\*(C`LGRP_LAT_CPU_TO_MEM\*(C'\fR to specify
between which hardware resources the latency should be measured. Currently the
only valid value is \f(CW\*(C`LGRP_LAT_CPU_TO_MEM\*(C'\fR which represents latency from \s-1CPU\s0 to
memory.
.Sp
Upon successful completion, \fIlgrp_latency_cookie()\fR return 1. Otherwise, it
returns \fBundef\fR and set \fB$!\fR to indicate the error. For \s-1LGRP API\s0 version 1 the
\&\fIlgrp_latency_cookie()\fR is an alias for \fIlgrp_latency()\fR.
.Sp
See lgrp_latency_cookie(3LGRP) for more information.
.ie n .IP "lgrp_latency($from, $to)" 4
.el .IP "lgrp_latency($from, \f(CW$to\fR)" 4
.IX Item "lgrp_latency($from, $to)"
The function is similiar to the \fIlgrp_latency_cookie()\fR function, but returns the
latency between the given lgroups at the given instant in time.  Since lgroups
may be freed and reallocated, this function may not be able to provide a
consistent answer across calls.  For that reason, it is recommended that
\&\fIlgrp_latency_cookie()\fR function be used in its place.
.Sp
See lgrp_latency(3LGRP) for more information.
.ie n .IP "lgrp_resources($cookie, $lgrp, $type)" 4
.el .IP "lgrp_resources($cookie, \f(CW$lgrp\fR, \f(CW$type\fR)" 4
.IX Item "lgrp_resources($cookie, $lgrp, $type)"
Return the list of lgroups directly containing resources of the specified type.
The resources are represented by a set of lgroups in which each lgroup directly
contains \s-1CPU\s0 and/or memory resources.
.Sp
The type can be specified as
.RS 4
.ie n .IP """LGRP_RSRC_CPU""" 4
.el .IP "\f(CWLGRP_RSRC_CPU\fR" 4
.IX Item "LGRP_RSRC_CPU"
\&\s-1CPU\s0 resources
.ie n .IP """LGRP_RSRC_MEM""" 4
.el .IP "\f(CWLGRP_RSRC_MEM\fR" 4
.IX Item "LGRP_RSRC_MEM"
Memory resources
.RE
.RS 4
.Sp
In case of error \fBundef\fR or empty list is returned and \fB$!\fR is set to indicate
the error.
.Sp
This function is only available for \s-1API\s0 version 2 and will return \fBundef\fR or
empty list for \s-1API\s0 version 1 and set $! to \f(CW\*(C`EINVAL\*(C'\fR.
.Sp
See \f(CW\*(C`lgrp_resources(3LGRP)\*(C'\fR for more information.
.RE
.IP "lgrp_lgrps($cookie, [$lgrp])" 4
.IX Item "lgrp_lgrps($cookie, [$lgrp])"
Returns list of all lgroups in a hierarchy starting from \f(CW$lgrp\fR. If \fB\f(CB$lgrp\fB\fR is
not specified, uses the value of lgrp_root($cookie). Returns the empty list on
failure.
.Sp
When called in scalar context, returns the total number of lgroups in the
system.
.IP "lgrp_leaves($cookie, [$lgrp])" 4
.IX Item "lgrp_leaves($cookie, [$lgrp])"
Returns list of all leaf lgroups in a hierarchy starting from \f(CW$lgrp\fR. If \f(CW$lgrp\fR is
not specified, uses the value of lgrp_root($cookie). Returns \fBundef\fR or empty
list on failure.
.Sp
When called in scalar context, returns the total number of leaf lgroups in the
system.
.ie n .IP "lgrp_isleaf($cookie, $lgrp)" 4
.el .IP "lgrp_isleaf($cookie, \f(CW$lgrp\fR)" 4
.IX Item "lgrp_isleaf($cookie, $lgrp)"
Returns \fBTrue\fR if \f(CW$lgrp\fR is leaf (has no children), \fBFalse\fR otherwise.
.SS "Object Methods"
.IX Subsection "Object Methods"
.IP "new([$view])" 4
.IX Item "new([$view])"
Creates a new Sun::Solaris::Lgrp object. An optional argument is passed to
\&\fIlgrp_init()\fR function. By default uses \f(CW\*(C`LGRP_VIEW_OS\*(C'\fR.
.IP "\fIcookie()\fR" 4
.IX Item "cookie()"
Returns a transparent cookie that may be passed to functions accepting cookie.
.IP "version([$version])" 4
.IX Item "version([$version])"
Without the argument returns the current version of the liblgrp(3LIB)
library. This is a wrapper for \fIlgrp_version()\fR with \f(CW\*(C`LGRP_VER_NONE\*(C'\fR as the
default version argument.
.IP "\fIstale()\fR" 4
.IX Item "stale()"
Returns \fBT\fR if the lgroup information in the object is stale, \fBF\fR
otherwise. It is a wrapper for \fIlgrp_cookie_stale()\fR.
.IP "\fIview()\fR" 4
.IX Item "view()"
Returns the snapshot's view of the lgroup hierarchy. It is a wrapper for
\&\fIlgrp_view()\fR.
.IP "\fIroot()\fR" 4
.IX Item "root()"
Returns the root lgroup. It is a wrapper for \fIlgrp_root()\fR.
.IP "children($lgrp)" 4
.IX Item "children($lgrp)"
Returns the list of lgroups that are children of the specified lgroup. This is a
wrapper for \fIlgrp_children()\fR.
.IP "parents($lgrp)" 4
.IX Item "parents($lgrp)"
Returns the list of lgroups that are parents of the specified lgroup. This is a
wrapper for \fIlgrp_parents()\fR.
.IP "\fInlgrps()\fR" 4
.IX Item "nlgrps()"
Returns the number of lgroups in the hierarchy. This is a wrapper for
\&\fIlgrp_nlgrps()\fR.
.ie n .IP "mem_size($lgrp, $type, $content)" 4
.el .IP "mem_size($lgrp, \f(CW$type\fR, \f(CW$content\fR)" 4
.IX Item "mem_size($lgrp, $type, $content)"
Returns the memory size of the given lgroup in bytes. This is a wrapper for
\&\fIlgrp_mem_size()\fR.
.ie n .IP "cpus($lgrp, $context)" 4
.el .IP "cpus($lgrp, \f(CW$context\fR)" 4
.IX Item "cpus($lgrp, $context)"
Returns the list of CPUs in the lgroup specified by \f(CW$lgrp\fR. This is a wrapper for
\&\fIlgrp_cpus()\fR.
.ie n .IP "resources($lgrp, $type)" 4
.el .IP "resources($lgrp, \f(CW$type\fR)" 4
.IX Item "resources($lgrp, $type)"
Returns the list of lgroups directly containing resources of the specified
type. This is a wrapper for \fIlgrp_resources()\fR.
.ie n .IP "home($idtype, $id)" 4
.el .IP "home($idtype, \f(CW$id\fR)" 4
.IX Item "home($idtype, $id)"
Returns the home lgroup for the given process or thread. This is a wrapper for
\&\fIlgrp_home()\fR.
.ie n .IP "affinity_get($idtype, $id, $lgrp)" 4
.el .IP "affinity_get($idtype, \f(CW$id\fR, \f(CW$lgrp\fR)" 4
.IX Item "affinity_get($idtype, $id, $lgrp)"
Returns the affinity that the \s-1LWP\s0 has to a given lgrp. This is a wrapper for
\&\fIlgrp_affinity_get()\fR.
.ie n .IP "affinity_set($idtype, $id, $lgrp, $affinity)" 4
.el .IP "affinity_set($idtype, \f(CW$id\fR, \f(CW$lgrp\fR, \f(CW$affinity\fR)" 4
.IX Item "affinity_set($idtype, $id, $lgrp, $affinity)"
Sets of LWPs specified by the \f(CW$idtype\fR and \f(CW$id\fR arguments have for the given lgroup.
This is a wrapper for \fIlgrp_affinity_set()\fR.
.IP "lgrps([$lgrp])" 4
.IX Item "lgrps([$lgrp])"
Returns list of all lgroups in a hierarchy starting from \f(CW$lgrp\fR (or the
\&\fIlgrp_root()\fR if \f(CW$lgrp\fR is not specified). This is a wrapper for \fIlgrp_lgrps()\fR.
.IP "leaves([$lgrp])" 4
.IX Item "leaves([$lgrp])"
Returns list of all leaf lgroups in a hierarchy starting from \fB\f(CB$lgrp\fB\fR. If \f(CW$lgrp\fR
is not specified, uses the value of \fIlgrp_root()\fR. This is a wrapper for
\&\fIlgrp_leaves()\fR.
.IP "isleaf($lgrp)" 4
.IX Item "isleaf($lgrp)"
Returns \fBTrue\fR if \fB\f(CB$lgrp\fB\fR is leaf (has no children), \fBFalse\fR otherwise.
This is a wrapper for \fIlgrp_isleaf()\fR.
.ie n .IP "latency($from, $to)" 4
.el .IP "latency($from, \f(CW$to\fR)" 4
.IX Item "latency($from, $to)"
Returns the latency value between a hardware resource in the \f(CW$from\fR lgroup to a
hardware resource in the \fB\f(CB$to\fB\fR lgroup. It will use \fIlgrp_latency()\fR for
version 1 of liblgrp(3LIB) and \fIlgrp_latency_cookie()\fR for newer versions.
.SS "\s-1EXPORTS\s0"
.IX Subsection "EXPORTS"
By default nothing is exported from this module. The following tags can be used
to selectively import constants and functions defined in this module:
.IP ":LGRP_CONSTANTS" 4
.IX Item ":LGRP_CONSTANTS"
\&\s-1LGRP_AFF_NONE, LGRP_AFF_STRONG, LGRP_AFF_WEAK, LGRP_CONTENT_DIRECT,
LGRP_CONTENT_HIERARCHY, LGRP_MEM_SZ_FREE, LGRP_MEM_SZ_INSTALLED,
LGRP_VER_CURRENT, LGRP_VER_NONE, LGRP_VIEW_CALLER, LGRP_VIEW_OS,
LGRP_NONE, LGRP_RSRC_CPU, LGRP_RSRC_MEM, LGRP_CONTENT_ALL,
LGRP_LAT_CPU_TO_MEM.\s0
.IP ":PROC_CONSTANTS" 4
.IX Item ":PROC_CONSTANTS"
P_PID, P_LWPID P_MYID
.IP ":CONSTANTS" 4
.IX Item ":CONSTANTS"
:LGRP_CONSTANTS, :PROC_CONSTANTS
.IP ":FUNCTIONS" 4
.IX Item ":FUNCTIONS"
\&\fIlgrp_affinity_get()\fR, \fIlgrp_affinity_set()\fR, \fIlgrp_children()\fR, \fIlgrp_cookie_stale()\fR,
\&\fIlgrp_cpus()\fR, \fIlgrp_fini()\fR, \fIlgrp_home()\fR, \fIlgrp_init()\fR, \fIlgrp_latency()\fR,
\&\fIlgrp_latency_cookie()\fR, \fIlgrp_mem_size()\fR, \fIlgrp_nlgrps()\fR, \fIlgrp_parents()\fR,
\&\fIlgrp_root()\fR, \fIlgrp_version()\fR, \fIlgrp_view()\fR, \fIlgrp_resources()\fR,
\&\fIlgrp_lgrps()\fR, \fIlgrp_leaves()\fR, \fIlgrp_isleaf()\fR, \fIlgrp_lgrps()\fR, \fIlgrp_leaves()\fR.
.IP ":ALL" 4
.IX Item ":ALL"
:CONSTANTS, :FUNCTIONS
.SS "Error values"
.IX Subsection "Error values"
The functions in this module return \fBundef\fR or an empty list when an underlying
library function fails. The \fB$!\fR is set to provide more information values for
the error. The following error codes are possible:
.IP "\s-1EINVAL\s0" 4
.IX Item "EINVAL"
The value supplied is not valid.
.IP "\s-1ENOMEM\s0" 4
.IX Item "ENOMEM"
There was not enough system memory to complete an operation.
.IP "\s-1EPERM\s0" 4
.IX Item "EPERM"
The effective user of the calling process does not have appropriate privileges,
and its real or effective user \s-1ID\s0 does not match the real or effective user \s-1ID\s0
of one of the threads.
.IP "\s-1ESRCH\s0" 4
.IX Item "ESRCH"
The specified  process or thread was not found.
.SS "Difference in the \s-1API\s0 versions"
.IX Subsection "Difference in the API versions"
The \f(CW\*(C`liblgrp(3LIB)\*(C'\fR is versioned. The exact version which was used to compile a
module is available through \fBlgrp_version\fR function.
.PP
Version 2 of the lgrpp_user \s-1API\s0 introduced the following constants and
functions, nbot present in version 1:
.ie n .IP """LGRP_RSRC_CPU"" constant" 4
.el .IP "\f(CWLGRP_RSRC_CPU\fR constant" 4
.IX Item "LGRP_RSRC_CPU constant"
.PD 0
.ie n .IP """LGRP_RSRC_MEM"" constant" 4
.el .IP "\f(CWLGRP_RSRC_MEM\fR constant" 4
.IX Item "LGRP_RSRC_MEM constant"
.ie n .IP """LGRP_CONTENT_ALL"" constant" 4
.el .IP "\f(CWLGRP_CONTENT_ALL\fR constant" 4
.IX Item "LGRP_CONTENT_ALL constant"
.ie n .IP """LGRP_LAT_CPU_TO_MEM"" constant" 4
.el .IP "\f(CWLGRP_LAT_CPU_TO_MEM\fR constant" 4
.IX Item "LGRP_LAT_CPU_TO_MEM constant"
.ie n .IP """lgrp_resources()"" function" 4
.el .IP "\f(CWlgrp_resources()\fR function" 4
.IX Item "lgrp_resources() function"
.ie n .IP """lgrp_latency_cookie()"" function" 4
.el .IP "\f(CWlgrp_latency_cookie()\fR function" 4
.IX Item "lgrp_latency_cookie() function"
.PD
.PP
The \f(CW\*(C`LGRP_RSRC_CPU\*(C'\fR and \f(CW\*(C`LGRP_RSRC_MEM\*(C'\fR are not defined for version 1. The
\&\fIlgrp_resources()\fR function is defined for version 1 but always returns empty
list. The \fIlgrp_latency_cookie()\fR function is an alias for lgrp_latency for
version 1.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
See \fIattributes\fR\|(5) for descriptions of the following attributes:
.PP
.Vb 7
\&  _\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_
\& |       ATTRIBUTE TYPE        |       ATTRIBUTE VALUE       |
\& |_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_|
\& | Availability                | SUNWpl5u                    |
\& |_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_|
\& | Interface Stability         | Unstable                    |
\& |_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_|
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
liblgrp(3LIB),
lgrp_affinity_get(3LGRP),
lgrp_affinity_set(3LGRP),
lgrp_children(3LGRP),
lgrp_cookie_stale(3LGRP),
lgrp_cpus(3LGRP),
lgrp_fini(3LGRP),
lgrp_home(3LGRP),
lgrp_init(3LGRP),
lgrp_latency(3LGRP),
lgrp_mem_size(3LGRP),
lgrp_nlgrps(3LGRP),
lgrp_parents(3LGRP),
lgrp_root(3LGRP),
lgrp_version(3LGRP),
lgrp_view(3LGRP),
lgrp_resources(3LGRP),
lgrp_latency_cookie(3LGRP),
\&\fIattributes\fR\|(5)
