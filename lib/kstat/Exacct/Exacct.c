/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.24 from the
 * contents of Exacct.xs. Do not edit this file, edit Exacct.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Exacct.xs"
/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2002 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 *
 * Exacct.xs contains XS code for creating various exacct-related constants,
 * and for providing wrappers around exacct error handling and
 * accounting-related system calls.  It also contains commonly-used utility
 * code shared by its sub-modules.
 */

#pragma ident	"%Z%%M%	%I%	%E% SMI"

#include <string.h>
#include "exacct_common.xh"

/*
 * Pull in the file generated by extract_defines.  This contains a table
 * of numeric constants and their string equivalents which have been extracted
 * from the various exacct header files by the extract_defines script.
 */
#include "ExacctDefs.xi"

/*
 * Object stash pointers - caching these speeds up the creation and
 * typechecking of perl objects by removing the need to do a hash lookup.
 * The peculiar variable names are so that typemaps can generate the correct
 * package name using the typemap '$Package' variable as the root of the name.
 */
HV *Sun_Solaris_Exacct_Catalog_stash;
HV *Sun_Solaris_Exacct_File_stash;
HV *Sun_Solaris_Exacct_Object_Item_stash;
HV *Sun_Solaris_Exacct_Object_Group_stash;
HV *Sun_Solaris_Exacct_Object__Array_stash;

/*
 * Pointer to part of the hash tree built by define_catalog_constants in
 * Catalog.xs.  This is used by catalog_id_str() when mapping from a catalog
 * to an id string.
 */
HV *IdValueHash = NULL;

/*
 * Last buffer size used for packing and unpacking exacct objects.
 */
static int last_bufsz = 0;

/*
 * Common utility code.  This is placed here instead of in the sub-modules to
 * reduce the number of cross-module linker dependencies that are required,
 * although most of the code more properly belongs in the sub-modules.
 */

/*
 * This function populates the various stash pointers used by the ::Exacct
 * module.  It is called from each of the module BOOT sections to ensure the
 * stash pointers are initialised on startup.
 */
void
init_stashes(void)
{
	if (Sun_Solaris_Exacct_Catalog_stash == NULL) {
		Sun_Solaris_Exacct_Catalog_stash =
		    gv_stashpv(PKGBASE "::Catalog", TRUE);
		Sun_Solaris_Exacct_File_stash =
		    gv_stashpv(PKGBASE "::File", TRUE);
		Sun_Solaris_Exacct_Object_Item_stash =
		    gv_stashpv(PKGBASE "::Object::Item", TRUE);
		Sun_Solaris_Exacct_Object_Group_stash =
		    gv_stashpv(PKGBASE "::Object::Group", TRUE);
		Sun_Solaris_Exacct_Object__Array_stash =
		    gv_stashpv(PKGBASE "::Object::_Array", TRUE);
	}
}

/*
 * This function populates the @_Constants array in the specified package
 * based on the values extracted from the exacct header files by the
 * extract_defines script and written to the .xi file which is included above.
 * It also creates a const sub for each constant that returns the associcated
 * value.  It should be called from the BOOT sections of modules that export
 * constants.
 */
#define	CONST_NAME "::_Constants"
void
define_constants(const char *pkg, constval_t *cvp)
{
	HV		*stash;
	char		*name;
	AV		*constants;

	/* Create the new perl @_Constants variable. */
	stash = gv_stashpv(pkg, TRUE);
	name = New(0, name, strlen(pkg) + sizeof (CONST_NAME), char);
	PERL_ASSERT(name != NULL);
	strcpy(name, pkg);
	strcat(name, CONST_NAME);
	constants = perl_get_av(name, TRUE);
	Safefree(name);

	/* Populate @_Constants from the contents of the generated array. */
	for (; cvp->name != NULL; cvp++) {
		newCONSTSUB(stash, (char *)cvp->name, newSVuv(cvp->value));
		av_push(constants, newSVpvn((char *)cvp->name, cvp->len));
	}
}
#undef CONST_NAME

/*
 * Return a new Catalog object - only accepts an integer catalog value.
 * Use this purely for speed when creating Catalog objects from other XS code.
 * All other Catalog object creation should be done with the perl new() method.
 */
SV*
new_catalog(uint32_t cat)
{
	SV *iv, *ref;

	iv = newSVuv(cat);
	ref = newRV_noinc(iv);
	sv_bless(ref, Sun_Solaris_Exacct_Catalog_stash);
	SvREADONLY_on(iv);
	return (ref);
}

/*
 * Return the integer catalog value from the passed Catalog or IV.
 * Calls croak() if the SV is not of the correct type.
 */
ea_catalog_t
catalog_value(SV *catalog)
{
	SV	*sv;

	/* If a reference, dereference and check it is a Catalog. */
	if (SvROK(catalog)) {
		sv = SvRV(catalog);
		if (SvIOK(sv) &&
		    SvSTASH(sv) == Sun_Solaris_Exacct_Catalog_stash) {
			return (SvIV(sv));
		} else {
			croak("Parameter is not a Catalog or integer");
		}

	/* For a plain IV, just return the value. */
	} else if (SvIOK(catalog)) {
		return (SvIV(catalog));

	/* Anything else is an error */
	} else {
		croak("Parameter is not a Catalog or integer");
	}
}

/*
 * Return the string value of the id subfield of an ea_catalog_t.
 */
char *
catalog_id_str(ea_catalog_t catalog)
{
	static ea_catalog_t	cat_val = ~0U;
	static HV		*cat_hash = NULL;
	ea_catalog_t		cat;
	ea_catalog_t		id;
	char			key[12];    /* Room for dec(2^32) digits. */
	SV			**svp;

	cat = catalog & EXC_CATALOG_MASK;
	id = catalog & EXD_DATA_MASK;

	/* Fetch the correct id subhash if the catalog has changed. */
	if (cat_val != cat) {
		snprintf(key, sizeof (key), "%d", cat);
		PERL_ASSERT(IdValueHash != NULL);
		svp = hv_fetch(IdValueHash, key, strlen(key), FALSE);
		if (svp == NULL) {
			cat_val = ~0U;
			cat_hash = NULL;
		} else {
			HV *hv;

			cat_val = cat;
			hv = (HV *)SvRV(*svp);
			PERL_ASSERT(hv != NULL);
			svp = hv_fetch(hv, "value", 5, FALSE);
			PERL_ASSERT(svp != NULL);
			cat_hash = (HV *)SvRV(*svp);
			PERL_ASSERT(cat_hash != NULL);
		}
	}

	/* If we couldn't find the hash, it is a catalog we don't know about. */
	if (cat_hash == NULL) {
		return ("UNKNOWN_ID");
	}

	/* Fetch the value from the selected catalog and return it. */
	snprintf(key, sizeof (key), "%d", id);
	svp = hv_fetch(cat_hash, key, strlen(key), TRUE);
	if (svp == NULL) {
		return ("UNKNOWN_ID");
	}
	return (SvPVX(*svp));
}

/*
 * Create a new ::Object by wrapping an ea_object_t in a perl SV.  This is used
 * to wrap exacct records that have been read from a file, or packed records
 * that have been inflated.
 */
SV *
new_xs_ea_object(ea_object_t *ea_obj)
{
	xs_ea_object_t	*xs_obj;
	SV		*sv_obj;

	/* Allocate space - use perl allocator. */
	New(0, xs_obj, 1, xs_ea_object_t);
	PERL_ASSERT(xs_obj != NULL);
	xs_obj->ea_obj = ea_obj;
	xs_obj->perl_obj = NULL;
	sv_obj = NEWSV(0, 0);
	PERL_ASSERT(sv_obj != NULL);

	/*
	 * Initialise according to the type of the passed exacct object,
	 * and bless the perl object into the appropriate class.
	 */
	if (ea_obj->eo_type == EO_ITEM) {
		if ((ea_obj->eo_catalog & EXT_TYPE_MASK) == EXT_EXACCT_OBJECT) {
			INIT_EMBED_ITEM_FLAGS(xs_obj);
		} else {
			INIT_PLAIN_ITEM_FLAGS(xs_obj);
		}
		sv_setiv(newSVrv(sv_obj, NULL), PTR2IV(xs_obj));
		sv_bless(sv_obj, Sun_Solaris_Exacct_Object_Item_stash);
	} else {
		INIT_GROUP_FLAGS(xs_obj);
		sv_setiv(newSVrv(sv_obj, NULL), PTR2IV(xs_obj));
		sv_bless(sv_obj, Sun_Solaris_Exacct_Object_Group_stash);
	}

	/*
	 * We are passing back a pointer masquerading as a perl IV,
	 * so make sure it can't be modified.
	 */
	SvREADONLY_on(SvRV(sv_obj));
	return (sv_obj);
}

/*
 * Convert the perl form of an ::Object into the corresponding exacct form.
 * This is used prior to writing an ::Object to a file, or passing it to
 * putacct.  This is only required for embedded items and groups - for normal
 * items it is a no-op.
 */
ea_object_t *
deflate_xs_ea_object(SV *sv)
{
	xs_ea_object_t	*xs_obj;
	ea_object_t	*ea_obj;

	/* Get the source xs_ea_object_t. */
	PERL_ASSERT(sv != NULL);
	sv = SvRV(sv);
	PERL_ASSERT(sv != NULL);
	xs_obj = INT2PTR(xs_ea_object_t *, SvIV(sv));
	PERL_ASSERT(xs_obj != NULL);
	ea_obj = xs_obj->ea_obj;
	PERL_ASSERT(ea_obj != NULL);

	/* Break any list this object is a part of. */
	ea_obj->eo_next = NULL;

	/* Deal with Items containing embedded Objects. */
	if (IS_EMBED_ITEM(xs_obj)) {
		xs_ea_object_t	*child_xs_obj;
		SV		*perl_obj;
		size_t		bufsz;

		/* Get the underlying perl object an deflate that in turn. */
		perl_obj = xs_obj->perl_obj;
		PERL_ASSERT(perl_obj != NULL);
		deflate_xs_ea_object(perl_obj);
		perl_obj = SvRV(perl_obj);
		PERL_ASSERT(perl_obj != NULL);
		child_xs_obj = INT2PTR(xs_ea_object_t *, SvIV(perl_obj));
		PERL_ASSERT(child_xs_obj->ea_obj != NULL);

		/* Free any existing object contents. */
		if (ea_obj->eo_item.ei_object != NULL) {
			ea_free(ea_obj->eo_item.ei_object,
			    ea_obj->eo_item.ei_size);
			ea_obj->eo_item.ei_object = NULL;
			ea_obj->eo_item.ei_size = 0;
		}

		/*  Pack the object. */
		while (1) {
			/* Use the last buffer size as a best guess. */
			if (last_bufsz != 0) {
				ea_obj->eo_item.ei_object =
				    ea_alloc(last_bufsz);
				PERL_ASSERT(ea_obj->eo_item.ei_object != NULL);
			} else {
				ea_obj->eo_item.ei_object = NULL;
			}

			/*
			 * Pack the object.  If the buffer is too small,
			 * we will go around again with the correct size.
			 * If unsucessful, we will bail.
			 */
			if ((bufsz = ea_pack_object(child_xs_obj->ea_obj,
			    ea_obj->eo_item.ei_object, last_bufsz)) == -1) {
				ea_free(ea_obj->eo_item.ei_object, last_bufsz);
				ea_obj->eo_item.ei_object = NULL;
				return (NULL);
			} else if (bufsz > last_bufsz) {
				ea_free(ea_obj->eo_item.ei_object, last_bufsz);
				last_bufsz = bufsz;
				continue;
			} else {
				ea_obj->eo_item.ei_size = bufsz;
				break;
			}
		}

	/* Deal with Groups. */
	} else if (IS_GROUP(xs_obj)) {
		MAGIC		*mg;
		AV		*av;
		int		len, i;
		xs_ea_object_t	*ary_xs;
		ea_object_t	*ary_ea, *prev_ea;

		/* Find the AV underlying the tie. */
		mg = mg_find(SvRV(xs_obj->perl_obj), 'P');
		PERL_ASSERT(mg != NULL);
		av = (AV*)SvRV(mg->mg_obj);
		PERL_ASSERT(av != NULL);

		/*
		 * Step along the AV, deflating each object and linking it into
		 * the exacct group item list.
		 */
		prev_ea = ary_ea = NULL;
		len = av_len(av) + 1;
		ea_obj->eo_group.eg_nobjs = 0;
		ea_obj->eo_group.eg_objs = NULL;
		for (i = 0; i < len; i++) {
			/*
			 * Get the source xs_ea_object_t.  If the current slot
			 * in the array is empty, skip it.
			 */
			SV	**ary_svp;
			if ((ary_svp = av_fetch(av, i, FALSE)) == NULL) {
				continue;
			}
			PERL_ASSERT(*ary_svp != NULL);

			/* Deflate it. */
			ary_ea = deflate_xs_ea_object(*ary_svp);
			PERL_ASSERT(ary_ea != NULL);

			/* Link into the list. */
			ary_ea->eo_next = NULL;
			if (ea_obj->eo_group.eg_objs == NULL) {
				ea_obj->eo_group.eg_objs = ary_ea;
			}
			ea_obj->eo_group.eg_nobjs++;
			if (prev_ea != NULL) {
				prev_ea->eo_next = ary_ea;
			}
			prev_ea = ary_ea;
		}
	}
	return (ea_obj);
}

/*
 * Private Sun::Solaris::Exacct utility code.
 */

/*
 * Return a string representation of an ea_error.
 */
static const char *
error_str(int eno)
{
	switch (eno) {
	case EXR_OK:
		return ("no error");
	case EXR_SYSCALL_FAIL:
		return ("system call failed");
	case EXR_CORRUPT_FILE:
		return ("corrupt file");
	case EXR_EOF:
		return ("end of file");
	case EXR_NO_CREATOR:
		return ("no creator");
	case EXR_INVALID_BUF:
		return ("invalid buffer");
	case EXR_NOTSUPP:
		return ("not supported");
	case EXR_UNKN_VERSION:
		return ("unknown version");
	case EXR_INVALID_OBJ:
		return ("invalid object");
	default:
		return ("unknown error");
	}
}

/*
 * The XS code exported to perl is below here.  Note that the XS preprocessor
 * has its own commenting syntax, so all comments from this point on are in
 * that form.
 */

#line 451 "Exacct.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 593 "Exacct.c"

XS_EUPXS(XS_Sun__Solaris__Exacct_ea_error); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Sun__Solaris__Exacct_ea_error)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 459 "Exacct.xs"
	int		eno;
	const char	*msg;
#line 605 "Exacct.c"
	SV *	RETVAL;
#line 462 "Exacct.xs"
	eno = ea_error();
	msg = error_str(eno);
	RETVAL = newSViv(eno);
	sv_setpv(RETVAL, (char*) msg);
	SvIOK_on(RETVAL);
#line 613 "Exacct.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Sun__Solaris__Exacct_ea_error_str); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Sun__Solaris__Exacct_ea_error_str)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 479 "Exacct.xs"
	int	eno;
#line 630 "Exacct.c"
	char *	RETVAL;
	dXSTARG;
#line 481 "Exacct.xs"
	eno = ea_error();
	if (eno == EXR_SYSCALL_FAIL) {
		RETVAL = strerror(errno);
		if (RETVAL == NULL) {
			RETVAL = "unknown system error";
		}
	} else {
		RETVAL = (char*) error_str(eno);
	}
#line 643 "Exacct.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Sun__Solaris__Exacct_getacct); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Sun__Solaris__Exacct_getacct)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "idtype, id");
    {
	idtype_t	idtype = (idtype_t)SvIV(ST(0))
;
	id_t	id = (id_t)SvIV(ST(1))
;
#line 502 "Exacct.xs"
	int		bufsz;
	char		*buf;
	ea_object_t	*ea_obj;
#line 665 "Exacct.c"
	SV *	RETVAL;
#line 506 "Exacct.xs"
	/* Get the required accounting buffer. */
	while (1) {
		/* Use the last buffer size as a best guess. */
		if (last_bufsz != 0) {
			buf = ea_alloc(last_bufsz);
			PERL_ASSERT(buf != NULL);
		} else {
			buf = NULL;
		}

		/*
		 * get the accounting record.  If the buffer is too small,
		 * we will go around again with the correct size.
		 * If unsucessful, we will bail.
		 */
		if ((bufsz = getacct(idtype, id, buf, last_bufsz)) == -1) {
			if (last_bufsz != 0) {
				ea_free(buf, last_bufsz);
			}
			XSRETURN_UNDEF;
		} else if (bufsz > last_bufsz) {
			ea_free(buf, last_bufsz);
			last_bufsz = bufsz;
			continue;
		} else {
			break;
		}
	}

	/* Unpack the buffer. */
	if (ea_unpack_object(&ea_obj, EUP_ALLOC, buf, bufsz) == -1) {
		ea_free(buf, last_bufsz);
		XSRETURN_UNDEF;
	}
	ea_free(buf, last_bufsz);
	RETVAL = new_xs_ea_object(ea_obj);
#line 704 "Exacct.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Sun__Solaris__Exacct_putacct); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Sun__Solaris__Exacct_putacct)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "idtype, id, value");
    {
	idtype_t	idtype = (idtype_t)SvIV(ST(0))
;
	id_t	id = (id_t)SvIV(ST(1))
;
	SV *	value = ST(2)
;
#line 557 "Exacct.xs"
	HV		*stash;
	unsigned int	bufsz;
	int		flags, ret;
	char		*buf;
#line 730 "Exacct.c"
	SV *	RETVAL;
#line 562 "Exacct.xs"
	/* If it is an ::Object::Item or ::Object::Group, pack it. */
	stash = SvROK(value) ? SvSTASH(SvRV(value)) : NULL;
	if (stash == Sun_Solaris_Exacct_Object_Item_stash ||
	    stash == Sun_Solaris_Exacct_Object_Group_stash) {
		ea_object_t	*obj;

		/* Deflate the object. */
		if ((obj = deflate_xs_ea_object(value)) == NULL) {
			XSRETURN_NO;
		}

		/*  Pack the object. */
		while (1) {
			/* Use the last buffer size as a best guess. */
			if (last_bufsz != 0) {
				buf = ea_alloc(last_bufsz);
				PERL_ASSERT(buf != NULL);
			} else {
				buf = NULL;
			}

			/*
			 * Pack the object.  If the buffer is too small, we
			 * will go around again with the correct size.
			 * If unsucessful, we will bail.
			 */
			if ((bufsz = ea_pack_object(obj, buf, last_bufsz))
			    == -1) {
				if (last_bufsz != 0) {
					ea_free(buf, last_bufsz);
				}
				XSRETURN_NO;
			} else if (bufsz > last_bufsz) {
				ea_free(buf, last_bufsz);
				last_bufsz = bufsz;
				continue;
			} else {
				break;
			}
		}
		flags = EP_EXACCT_OBJECT;

	/* Otherwise treat it as normal SV - convert to a string. */
	} else {
		buf = SvPV(value, bufsz);
		flags = EP_RAW;
	}

	/* Call putacct to write the buffer */
	RETVAL = putacct(idtype, id, buf, bufsz, flags) == 0
	    ? &PL_sv_yes : &PL_sv_no;

	/*  Clean up if we allocated a buffer. */
	if (flags == EP_EXACCT_OBJECT) {
		ea_free(buf, last_bufsz);
	}
#line 789 "Exacct.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Sun__Solaris__Exacct_wracct); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Sun__Solaris__Exacct_wracct)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "idtype, id, flags");
    {
	idtype_t	idtype = (idtype_t)SvIV(ST(0))
;
	id_t	id = (id_t)SvIV(ST(1))
;
	int	flags = (int)SvIV(ST(2))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = wracct(idtype, id, flags);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Sun__Solaris__Exacct); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Sun__Solaris__Exacct)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        (void)newXSproto_portable("Sun::Solaris::Exacct::ea_error", XS_Sun__Solaris__Exacct_ea_error, file, "");
        (void)newXSproto_portable("Sun::Solaris::Exacct::ea_error_str", XS_Sun__Solaris__Exacct_ea_error_str, file, "");
        (void)newXSproto_portable("Sun::Solaris::Exacct::getacct", XS_Sun__Solaris__Exacct_getacct, file, "$$");
        (void)newXSproto_portable("Sun::Solaris::Exacct::putacct", XS_Sun__Solaris__Exacct_putacct, file, "$$$");
        (void)newXSproto_portable("Sun::Solaris::Exacct::wracct", XS_Sun__Solaris__Exacct_wracct, file, "$$$");

    /* Initialisation Section */

#line 448 "Exacct.xs"
	init_stashes();
	define_constants(PKGBASE, constants);

#line 851 "Exacct.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

