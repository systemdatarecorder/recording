#!/opt/sdr/perl/bin/perl
#
#  Copyright (c) 2014 Stefan Parvu (www.systemdatarecorder.org).
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#  (http://www.gnu.org/copyleft/gpl.html)

use strict;
use warnings;
use Getopt::Std;
use Time::HiRes qw(time alarm setitimer ITIMER_REAL);
use POSIX qw(pause);

#
# Command line arguments
#
usage() if defined $ARGV[0] and $ARGV[0] eq "--help";
getopts('hV') or usage();
usage()    if defined $main::opt_h;
revision() if defined $main::opt_V;

# process [[interval [count]]
my ( $interval, $loop_max );
if ( defined $ARGV[0] ) {
    $interval = $ARGV[0];
    $loop_max = defined $ARGV[1] ? $ARGV[1] : 2**32;
    usage() if $interval == 0;
}
else {
    $interval = 1;
    $loop_max = 1;
}

# globals
local $| = 1;    # autoflush
my $loop = 0;    # current loop number
my $tp   = 0;    # time precision
$main::opt_h = 0;
$main::opt_V = 0;
my $xentop = "/usr/sbin/xentop";


# ######### #
# MAIN BODY #
# ######### #

# how often do we trigger
my $first_interval = $interval;

# signal handler is empty, do nothing
local $SIG{ALRM} = sub { };

# first value is the initial wait, second is the wait thereafter
setitimer( ITIMER_REAL, $first_interval, $interval );

if ( $interval =~ /\./ ) {
    $tp = 3;
}

while (1) {

    # load current stats
    my @stats = get_stat();

    # printf "%.${tp}f:%s\n", time, @stats;

    ### Check for end
    last if ++$loop == $loop_max;

    ### Interval
    pause;
}


# ########### #
# SUBROUTINES #
# ########### #

sub get_param {
    my ($entry) = @_;
    my $param;

    if ( $entry =~ /(\d+)\s*active connections openings/ ) {
        $param = $1;
    }
    elsif ( $entry =~ /(\d+)\s*passive connection openings/ ) {

        #push @params, $1;
        $param = $1;
    }
    elsif ( $entry =~ /(\d+)\s*failed connection attempts/ ) {
        $param = $1;
    }
    elsif ( $entry =~ /(\d+)\s*connection resets received/ ) {
        $param = $1;
    }
    elsif ( $entry =~ /(\d+)\s*connections established/ ) {
        $param = $1;
    }
    elsif ( $entry =~ /(\d+)\s*resets sent/ ) {
        $param = $1;
    }
    elsif ( $entry =~ /(\d+)\s*packets received/ ) {
        $param = $1;
    }
    elsif ( $entry =~ /(\d+)\s*packets sent/ ) {
        $param = $1;
    }
    elsif ( $entry =~ /(\d+)\s*fast retransmits/ ) {
        $param = $1;
    }
    elsif ( $entry =~ /(\d+)\s*forward retransmits/ ) {
        $param = $1;
    }
    elsif ( $entry =~ /(\d+)\s*retransmits in slow start/ ) {
        $param = $1;
    }

    return $param;
}


sub get_stat {

    my @stat = ();

    open my $fh, "-|", "$xentop", "-b", "-d0", "-i2"
      or die "cannot execute '$xentop' - $!";

    while (<$fh>) {
        next if /NAME/ ... /NAME/;
        print $_;
        # push @stat, get_param($_) if ( defined( get_param($_) ) );
    }
    #close $fh;

    #@stat = join( ":", @stat );
    return @stat;
}


# usage - print usage and exit.
sub usage {
    print STDERR <<END;
USAGE: xenrec [-hV] | [interval [count]]
 e.g. xenrec 5       print continuously, every 5 seconds
      xenrec 1 5     print 5 times, every 1 second

 FIELDS:
  #01 timestamp  : seconds since Epoch, time
  #02 name       : domain name, the guest name
  #03 state      : domain state: blocked (b), dying (d), shutdown (s)
                    crashed (c), paused (p), running (r)
  #04 cputime    : displays cpu usage in seconds
  #05 cpupct     : displays cpu usage in percentage
  #06 vcpus      : number of vCPUs
  #07 nets       : number of virtual networks
  #08 mem        : current memory
  #09 maxmem     : maximum domain memory stats, in KB
  #10 maxmempct  : memory stats in percentage, ratio of current domain 
                     memory to total node memory
  #11 nettx      : number of total network transmits bytes statistic
  #12 netrx      : number of total network received bytes statistic
  #13 vbds       : number of virtual block devices
  #14 vbdoo      : number of total VBD OO requests
  #15 vbdrd      : number of VBD read requests
  #16 vbdwr      : number of VBD write requests
  #17 vbdrsect   : number of VBD read sectors
  #18 vbdwsect   : number of VBD write sectors
  #19 ssid       : security id

  Note: VBD, Virtual Block Device
END
    exit 0;
}



# revision - print revision and exit
sub revision {
    print STDERR <<END;
xenrec: 1.00, 2014-04-27
END
    exit 0;
}
