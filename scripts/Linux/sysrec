#!/opt/sdr/perl/bin/perl

# COPYRIGHT: Copyright (c) 2013 System Data Recorder
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#  (http://www.gnu.org/copyleft/gpl.html)

# SDR VERSION: 0.74.2

use strict;
use warnings;
use Getopt::Std;
use Time::HiRes qw(time alarm setitimer ITIMER_REAL);
use Sys::Statistics::Linux;
use POSIX qw(pause);

#
#  Process command line args
#
usage() if defined $ARGV[0] and $ARGV[0] eq "--help";
getopts('hV') or usage();
usage()    if defined $main::opt_h;
revision() if defined $main::opt_V;

# process [interval [count]],
my ( $interval, $loop_max );
if ( defined $ARGV[0] ) {
    $interval = $ARGV[0];
    $loop_max = defined $ARGV[1] ? $ARGV[1] : 2**32;
    usage() if $interval == 0;
}
else {
    $interval = 1;
    $loop_max = 1;
}

#
#  Variables
#
my $loop = 0;    # current loop number
my $tp   = 0;    # time precision
$main::opt_h = 0;    # help option

#$main::opt_v = 0;   # verbose option
$main::opt_V = 0;    # revision option
local $| = 1;

# Set a timer for S::S::L object
local $SIG{ALRM} = sub { };
setitimer( ITIMER_REAL, .1, .1 );
my $lxs = Sys::Statistics::Linux->new(
    cpustats  => 1,
    memstats  => 1,
    diskstats => 1,
    netstats  => 1,
    loadavg   => 1
);
### 0.1sec sleep using a timer
pause;

# $lxs is now properly initialized

# how often do we trigger (seconds)?
my $first_interval = $interval;

# signal handler is empty
local $SIG{ALRM} = sub { };

# first value is the initial wait, second is the wait thereafter
setitimer( ITIMER_REAL, $first_interval, $interval );

if ( $interval =~ /\./ ) {
    $tp = 3;
}

while (1) {

    # disks might become available, check disks every sample
    my @disks;

    my ( $readReq, $readByt, $writeReq, $writeByt, $totReq, $totByt ) = 0;

    # net stats
    my ( $rxByt, $txByt, $ntByt, $rxerr, $txerr, $rxdrp, $txdrp ) = 0;

    # runq_sz and process count
    my ($runq_sz, $count) = 0;

    ### Get Stats
    my $stat    = $lxs->get;

    # Dump $lx variable
    # use Data::Dumper;
    # print Dumper($stat);

    my $cpu     = $stat->cpustats->{cpu};
    my $mem     = $stat->memstats;
    my $disk    = $stat->diskstats;
    my $nic     = $stat->netstats;
    my $la      = $stat->loadavg;

    # sum(cpus)
    my $scpus = $stat->cpustats;
    my @cpus = sort $stat->cpustats;
    my ($ncpu, $numcpus) = 0;

    foreach (@cpus) {
        next if ( $_ eq "cpu" );
        $ncpu += $scpus->{$_}{total};
        $numcpus++;
    }

    # headroom cpu
    my $hcpu = ($numcpus * 100) - $ncpu;


    # get disks
    open my $DISKS, "<", "/proc/partitions"
      or die "Error: Cannot find proc partitions file: $!\n";

    while (<$DISKS>) {
        my $disk = get_part($_);
        next if ( !defined($disk) );
        push @disks, "$disk";
    }

    close $DISKS;


    # loop over all disks
    foreach (@disks) {

        #
        # print "\nDisk: $_ \n";

        if ( defined( $disk->{$_}{rdreq} ) ) {
            $readReq += $disk->{$_}{rdreq};
        }

        if ( defined( $disk->{$_}{wrtreq} ) ) {
            $writeReq += $disk->{$_}{wrtreq};
        }

        if ( defined( $disk->{$_}{ttreq} ) ) {
            $totReq += $disk->{$_}{ttreq};
        }

        if ( defined( $disk->{$_}{rdbyt} ) ) {
            $readByt += ( $disk->{$_}{rdbyt} / 1024 );
        }

        if ( defined( $disk->{$_}{wrtbyt} ) ) {
            $writeByt += ( $disk->{$_}{wrtbyt} / 1024 );
        }

        if ( defined( $disk->{$_}{ttbyt} ) ) {
            $totByt += ( $disk->{$_}{ttbyt} / 1024 );
        }

        ### Debug
        #print "readReq = $readReq \n";
        #print "writeReq = $writeReq \n";
        #print "totReq = $totReq \n";
        #print "readBytes = $readByt\n";
        #print "writeReq = $writeByt \n";
        #print "totByt = $totByt \n";
    }

    ### Get NICS
    my @nics = sort $stat->netstats;

    # loop over all NICS
    foreach (@nics) {

        # skip here the non eth NICs
        next if $_ !~ /^eth.*/;

        #
        # print "NIC: $_ \n";
        if ( defined( $nic->{$_}{rxbyt} ) ) {
            $rxByt += ( $nic->{$_}{rxbyt} / 1024 );
        }

        if ( defined( $nic->{$_}{txbyt} ) ) {
            $txByt += ( $nic->{$_}{txbyt} / 1024 );
        }

        if ( defined( $nic->{$_}{ttbyt} ) ) {
            $ntByt += ( $nic->{$_}{ttbyt} / 1024 );
        }

        if ( defined( $nic->{$_}{rxerrs} ) ) {
            $rxerr += ( $nic->{$_}{rxerrs} );
        }

        if ( defined( $nic->{$_}{txerrs} ) ) {
            $txerr += ( $nic->{$_}{txerrs} );
        }

        if ( defined( $nic->{$_}{rxdrop} ) ) {
            $rxdrp += ( $nic->{$_}{rxdrop} );
        }

        if ( defined( $nic->{$_}{txdrop} ) ) {
            $txdrp += ( $nic->{$_}{txdrop} );
        }

    }

    # get runq_sz and process count from /proc/loadavg
    open my $LA, "<", "/proc/loadavg"
      or die "Error: Cannot find proc partitions file: $!\n";
 
    while (<$LA>) {
        ($runq_sz, $count) = (split m@/@, (split /\s+/, $_)[3]);
    }

    close $LA;

    # exclude from runqa_sz current process
    $runq_sz--;

    # print metrics
    # sdrd 0737 43 fields
    # timestamp %.${tp}f:
    # cpu %.2f:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f:%d:%d:
    # mem %.2f:%d:%d:%d:%d:%d:%d:%.2f:%.2f:%d:%d:%d:%d:
    # disk %d:%d:%d:%.2f:%.2f:%.2f:
    # net %.2f:%.2f:%.2f:%d:%d:%d:%d:
    # oth %.2f:%.2f:%.2f

    printf
         "%.${tp}f:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f:%d:%d:%.2f:%d:%d:%d:%d:%d:%d:%.2f:%.2f:%d:%d:%d:%d:%d:%d:%d:%.2f:%.2f:%.2f:%.2f:%.2f:%.2f:%d:%d:%d:%d:%.2f:%.2f:%.2f\n",
          time,
          $cpu->{total},  $ncpu,        $hcpu, 
          $cpu->{user},   $cpu->{nice}, $cpu->{system},  $cpu->{idle},
          $cpu->{iowait}, $cpu->{irq},  $cpu->{softirq}, $cpu->{steal},
          $runq_sz,       $count,
          $mem->{memusedper},  $mem->{memused},
          $mem->{memfree},     $mem->{memtotal},
          $mem->{buffers},     $mem->{cached},
          $mem->{realfree},    $mem->{realfreeper},
          $mem->{swapusedper}, $mem->{swapused},
          $mem->{swapfree},    $mem->{swaptotal},
          $mem->{swapcached},

          $readReq, $writeReq, $totReq,
          $readByt, $writeByt, $totByt,

          $rxByt,   $txByt,    $ntByt,
          $rxerr, $txerr, $rxdrp, $txdrp,

          $la->{avg_1}, $la->{avg_5}, $la->{avg_15};

    ### Check for end
    last if ++$loop == $loop_max;

    ### Interval
    pause;

}

sub get_part {
    my ($entry) = @_;
    my ( $s, $maj, $min, $bks, $name );

    chomp $entry;
    return if $entry =~ /^major/;
    return if $entry =~ /^$/;
   
    # we return any valid partition number, we skip entire disk
    if ($entry =~ /(?:[0-9])$/) {
        ( $s, $maj, $min, $bks, $name ) = split /\s+/, $entry;
        return $name;
    }

    return;
}

# revision - print revision and exit
#
sub revision {
    print STDERR <<END;
sysrec: 0.74.2, 2013-01-30
 sdrd format: 0737 43
END
    exit 0;
}

# usage - print usage and exit.
#
sub usage {
    print STDERR <<END;
USAGE: sysrec [-hV] | [interval [count]]
 e.g. sysrec 5        print continuously, every 5 seconds
      sysrec 1 5      print 5 times, every 1 second
      sysrec .5       print continuously, every 0.5 seconds

 FIELDS:
  CPU
   #01 timestamp  : seconds since Epoch
   #02 cpupct     : cpu utilization, across all cpus, percentage, gauge
   #03 sumpct     : sum of all cpus utilization, percentage, gauge
   #04 headpct    : headroom cpu available, all cpus, percentage, gauge
   #05 userpct    : cpu utilization, user space in percent, gauge
   #06 nicepct    : cpu utilization, user space with nice priority, gauge
   #07 sysct      : cpu utilization, system space, gauge
   #08 idlepct    : cpu utilization, idle state, gauge
   #09 iowaitcpt  : cpu percentage in idle state because an I/O operation 
                     is waiting to complete, gauge
   #10 irqpct     : cpu percentage servicing interrupts, gauge
   #11 softirqpct : cpu percentage servicing softirqs, gauge
   #12 stealpct   : cpu percentage of time spent in other operating systems
                    when running in a virtualized environment, gauge
   #13 runqsz     : run queue length, number of tasks waiting for run time
   #14 plistsz    : number of tasks in the task list

  MEM
   #15 memusedpct : size of used memory in percent, gauge
   #16 memused    : size of used memory in kilobytes, gauge
   #17 memfree    : size of free memory in kilobytes, gauge
   #18 memtotal   : size of memory in kilobytes, gauge
   #19 buffers    : size of buffers used from memory in kilobytes, gauge
   #20 cached     : size of cached memory in kilobytes, gauge
   #21 realfree   : size of memory is real free, gauge 
                     (memfree+buffers+cached)
   #22 realfreepct: size of memory is real free in percent of total memory,
                     gauge
   #23 swapusedpct: size of used swap space in percent, gauge
   #24 swapused   : size of swap space is used is kilobytes, gauge
   #25 swapfree   : size of swap space is free in kilobytes, gauge
   #26 swaptotal  : size of swap space in kilobytes, gauge
   #27 swapcached : memory that once was swapped out, is swapped back in 
                     but still also is in the swapfile, gauge

  DISK
   #28 readReq    : disk read requests, gauge
   #29 writeReq   : disk write requests, gauge
   #30 totReq     : disk read+write requests, gauge
   #31 readByt    : read bytes/sec, in KB, gauge
   #32 writeByt   : write bytes/sec, in KB, gauge
   #33 totByt     : read+write bytes/sec, in KB, gauge

  NET
   #34 rxByt      : received bytes/sec, in KB, gauge
   #35 txByt      : transmitted bytes/sec, in KB, gauge
   #36 ntByt      : received + transmitted bytes /sec, in KB, gauge
   #37 rxerr      : number of errors that happend while received pkt/sec
   #38 txerr      : number of errors that happend while transmitting pkt/sec
   #39 rxdrp      : number of rx packets that were dropped per second
   #40 txdrp      : number of tx packets that were dropped per second
 
   #41 avg_1      : LA of the last minute
   #42 avg_5      : LA of the last 5 minutes
   #43 avg_15     : LA of the last 15 minutes

END
    exit 0;
}

